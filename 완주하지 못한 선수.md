### notice
array.slice(start,end) 는 인덱스 변화 X, 값 삭제<Br/>
array.splice(start,end)는 인덱스 변화 O, 값 삭제

### Reference
[해쉬](https://evan-moon.github.io/2019/06/25/hashtable-with-js/)

#### 1 효율성 zero 
```javascript
function solution(participant, completion) {
    
    let i,j;
    let p = participant;
    let c = completion;
    
    while(c.length > 0){
        i=0;
        j=0;
        let check = c[i];
        
        for(j; j<p.length; j++){
            if(c[i]==p[j]){
                c.splice(i,1);
                p.splice(j,1);
                break;
            }
        }
    }
    
    var answer = '';
    answer = p.join('');
    
    return answer;
}
```
### 2 해쉬를 써야해
직접 주소 테이블은 값에 접근하기는 편하지만 공간 효율이 좋지 않다는 단점이 있다. <br/>
그래서 이 단점을 보완한 게 바로 해시 테이블인 것이다.<br/>

해시 테이블은 직접 주소 테이블처럼 값을 바로 테이블의 인덱스로 사용하는 것이 아니라 해시 함수(Hash Function)이라는 것에 한번 통과시켜서 사용한다. <br/>
해시 함수는 임의의 길이를 가지는 임의의 데이터를 고정된 길이의 데이터로 매핑하는 함수이다. <br/>
이때 이 함수가 뱉어내는 결과물을 해시(Hash)라고 부른다.<br/>

```javascript
// 예시
function hashFunction (key) {
  return key % 10;
}

console.log(hashFunction(102948)); // 8
console.log(hashFunction(191919191)); // 1
console.log(hashFunction(13)); // 3
console.log(hashFunction(997)); // 7
```
```javascript
// 왜 
function solution(participant, completion) {
    
    let i,j;
    let p = participant;
    let c = completion;
    let dic = {};
    
    for (i=0; i<p.length; i++){
        if(!(p[i] in dic)){
            dic[p[i]] = 0;    
        }else{
            dic[p[i]] = 1;
        }
    }
    
    for(j=0; j<c.length; j++){
        if (c[j] in dic){
            if(dic[c[j]]==0){
                delete dic[c[j]];    
            }else{
                continue;
            }
        }
    }
    
    var answer = '';
    answer = (Object.keys(dic).join(''));

    return answer;
}
```
